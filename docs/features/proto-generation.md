# Proto Generation

To be able to generate proto you need to register your service first. To do so please refer to [https://socotecio.github.io/django-socio-grpc/server_and_service_register/#service-registration](https://socotecio.github.io/django-socio-grpc/server_and_service_register/#service-registration)

## Command

To automatically generate proto and python files use the generateproto command:

```bash
python manage.py generateproto
```

Options Available:

| Option | Shortcut | Default value | Description |
| ------ | ------ | ------ | ----------- |
| --project   | -p   | Use DJANGO_SETTINGS_MODULE first folder | Name of the django project that is use in the proto package name. |
| --dry-run    | -dr    | False    | Print in terminal the protofile content without writing it to a file or generate new python code. |
| --generate-python    | -gp    | True    | Generate python file same time you generate proto file. |
| --check    | -c    | False    | Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models. |


## Settings configuration

As all the services are register at the launch of the server and not at the command level if we want to customize some behavior in the register process we need to use django settings.

| Setting | Default value | Description |
| ------ | ------ | ----------- |
| GRPC_FRAMEWORK.SEPARATE_READ_WRITE_MODEL | True | use the field fonctionnality read_only and write_only to seperate request message and response message. |

For all the following example we will show result with default value of settings.

## Default generation

By default each service registered inheriting from know mixins will generate the default method and message in proto file.

For example if we have a service that inherit from AsyncModelService and serializer like this:

```python
# Serializer
from django_socio_grpc import proto_serializers
from .models import Something


class SomethingProtoSerializer(proto_serializers.ModelProtoSerializer):
    class Meta:
        model = Something
        fields = ["uuid", "start_date", "rate"]

# Service
from django_socio_grpc import generics
from ..models import Something
from ..serializers import SomethingProtoSerializer


class SomethingService(generics.AsyncModelService):
    queryset = Something.objects.all()
    serializer_class = SomethingProtoSerializer

```

this will generate a proto like:
```proto
syntax = "proto3";

package doc_example.generate_proto_doc;

import "google/protobuf/empty.proto";

service SomethingController {
    rpc List(SomethingListRequest) returns (SomethingListResponse) {}
    rpc Create(SomethingRequest) returns (SomethingResponse) {}
    rpc Retrieve(SomethingRetrieveRequest) returns (SomethingResponse) {}
    rpc Update(SomethingRequest) returns (SomethingResponse) {}
    rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {}
}

message SomethingResponse {
    string uuid = 1;
    string start_date = 2;
    string rate = 3;
}

message SomethingListRequest {
}

message SomethingListResponse {
    repeated SomethingResponse results = 1;
}

message SomethingRequest {
    string uuid = 1;
    string start_date = 2;
    string rate = 3;
}

message SomethingRetrieveRequest {
    string uuid = 1;
}

message SomethingDestroyRequest {
    string uuid = 1;
}
```

To see more complex usage without reading the doc please look at the code used for the unit tests:

[See services example used for test here](https://github.com/socotecio/django-socio-grpc/tree/master/django_socio_grpc/tests/fakeapp/services)
[See serializers example used for test here](https://github.com/socotecio/django-socio-grpc/blob/master/django_socio_grpc/tests/fakeapp/serializers.py)

## Adding Custom method (Decorator)

You can add custome method (one not listed in mixins file: List, Create, Update, PartialUpdate, Retrieve, Delete, Stream) with the decorator grpc_action

This decorator signature is:
```python
def grpc_action(request=None, response=None, request_name=None, response_name=None, request_stream=False, response_stream=False, use_request_list=False, use_response_list=False)
```

### Request and Response arg

request and response are the variable used to define the field in the request/response proto message.

It can be a string, a list of dict or a serializer.

1.String format

Inject directly the string as message. Usefull if you want to use a already declared custom message or some specific type like `google.protobuf.Empty`.

2.List of dict format

Transform the dict inside the list into proto field. Usefull if you have only 1 or 2 field and doesn't want to create a serializer
Dict format is:

```python
{
    "name": "field_name",
    "type": "existing_protobuf_type"
}
```

3.Serializer

Use a Serializer class to create the proto message in the same way that it work for know method.

Example:

```python
class BasicServiceSerializer(proto_serializers.ProtoSerializer):

user_name = serializers.CharField()
user_data = serializers.DictField()

class Meta:
    fields = ["user_name", "user_data"]

class BasicService(generics.GenericService):
    @grpc_action(
        request=[{"name": "user_name", "type": "string"}],
        response=BasicServiceSerializer,
    )
    async def FetchDataForUser(self, request, context):
        pass
```

Generate:

```proto
service BasicController {
    rpc FetchDataForUser(BasicFetchDataForUserRequest) returns (BasicServiceResponse) {}
}

message BasicFetchDataForUserRequest {
    string user_name = 1;
}

message BasicServiceResponse {
    string user_name = 1;
    google.protobuf.Struct user_data = 2;
}
```


### request_name and response_name arg

Used to force a name for the message used.


### request_stream and response_stream arg

Used to mark the request or the response as a stream in the protobuf file

### use_request_list and use_response_list arg

Used to encapsulate the message inside a List message.

You need to use it if you return a serializer message with many=True at initialisation

## Force message for know method

You can use `grpc_action` decorator on know method to override default message.

```python
class SomethingService(generics.AsyncModelService):
    queryset = SpecialFieldsModel.objects.all().order_by("uuid")
    serializer_class = SpecialFieldsModelSerializer

    @grpc_action(
        request=[{"name": "thing", "type": "string"}],
        response=[{"name": "anything", "type": "string"}],
    )
    async def Retrieve(self, request, context):
        pass
```

Generate:

```proto

import "google/protobuf/empty.proto";

service SomethingController {
    ...
    rpc Retrieve(SomethingRetrieveRequest) returns (SomethingRetrieveResponse) {}
    ...
}

...

message SomethingRetrieveRequest {
    string thing = 1;
}

message SomethingRetrieveResponse {
    string anything = 1;
}

...
```

## Read Only and write only props

If the settings `SEPARATE_READ_WRITE_MODEL` is true. Django Socio gRPC will automatically use read_only and write_only field kwargs to generate field only in request or response message.
This is also true for django field with specific value (editable=False or similar)

Example:

```python
class BasicServiceSerializer(proto_serializers.ProtoSerializer):

    user_name = serializers.CharField(read_only=True)
    email = serializers.CharField()
    password = serializers.CharField(write_only=True)

    class Meta:
        fields = ["user_name", "email", "password"]
```

Generate a message like:

```proto
message BasicServiceRequest {
    string user_name = 1;
    string password = 2;
}

message BasicServiceResponse {
    string user_name = 1;
    string email = 2;
}
```

## Nested serializer

Django Socio gRPC support nested serializer without no extra work. Just try it.

```python
class RelatedFieldModelSerializer(proto_serializers.ModelProtoSerializer):
    foreign_obj = ForeignModelSerializer(read_only=True)
    many_many_obj = ManyManyModelSerializer(read_only=True, many=True)

    class Meta:
        model = RelatedFieldModel
        fields = ["uuid", "foreign_obj", "many_many_obj"]
```

```proto
message RelatedFieldModelResponse {
    string uuid = 1;
    ForeignModelResponse foreign_obj = 2;
    repeated ManyManyModelResponse many_many_obj = 3;
}
```

## Special case of BaseProtoSerializer

As BaseProtoSerializer doesn't have fields but only to_representation and to_internal_value we can't automatically instropect code to find the correct proto type.

To address this issue you have to manually declare the name and protobuf type of the BaseProtoSerializer in a `to_proto_message` method.

This `to_proto_message` need to return a list of dict in the same format that `grpc_action` request or response as list input.

```python
class BaseProtoExampleSerializer(proto_serializers.BaseProtoSerializer):
    def to_representation(self, el):
        return {
            "uuid": str(el.uuid),
            "number_of_elements": el.number_of_elements,
            "is_archived": el.is_archived,
        }

    def to_proto_message(self):
        return [
            {"name": "uuid", "type": "string"},
            {"name": "number_of_elements", "type": "int32"},
            {"name": "is_archived", "type": "bool"},
        ]
```

```proto
message BaseProtoExampleResponse {
    string uuid = 1;
    int32 number_of_elements = 2;
    bool is_archived = 3;
}
```

## Special case of MethodSerializerField

DRF MethodSerializerField class is a field type that return the result of a method. So there is no possibility to automatically find the type of this field.
To contourn this problem Django Socio gRPC introduce function introspection where we are looking for return annotation in the method to find the prototype

```python
from typing import List, Disct

class ExampleSerializer(
    proto_serializers.ProtoSerializer
):

    default_method_field = serializers.SerializerMethodField()
    custom_method_field = serializers.SerializerMethodField(method_name="custom_method")

    def get_default_method_field(self, obj) -> int:
        return 3

    def custom_method(self, obj) -> List[Dict]:
        return [{"test": "test"}]

    class Meta:
        fields = ["default_method_field", "custom_method_field"]
```

```proto
message ExampleResponse {
    int32 default_method_field = 2;
    repeated google.protobuf.Struct custom_method_field = 3;
}
```


## Customizing the name of the field in the ListResponse

By default the name of the field used for list response is `results`. You can override it in the meta of your serializer:

```python
class ExampleSerializer(proto_serializers.ProtoSerializer):

    uuid = serializers.CharField()
    name = serializers.CharField()

    class Meta:
        message_list_attr = "list_custom_field_name"
        fields = ["uuid", "name"]

```

```proto
message ExampleResponse {
    string uuid = 1;
    string name = 2;
}

message ExampleListResponse {
    repeated ExampleResponse list_custom_field_name = 1;
    int32 count = 2;
}
```


## Add comments to fields

You could specify comments for fields in your model (proto message) via `help_text` attribute and `django_socio_grpc.utils.tools.ProtoComment` class:

```python
class ExampleSerializer(proto_serializers.ProtoSerializer):

    name = serializers.CharField(help_text=ProtoComment(["Comment for the name field"]))
    value = serializers.CharField(help_text=ProtoComment(["Multiline comment", "for the value field"]))

    class Meta:
        fields = ["name", "value"]

```

```proto
message ExampleResponse {
    // Comment for the name field
    string name = 1;
    // Multiline comment
    // for the value field
    string value = 2;
}
```
