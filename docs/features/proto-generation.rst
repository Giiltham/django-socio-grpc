.. _proto-generation:

Proto generation
================

To be able to generate proto files you need to register your service first.
To do so please refer to :ref:`getting started <getting_started>` at section service registration

Description
-----------

Proto files contain the classes, descriptors and controller logic (``pb2.py`` files) and proto message syntax (``.proto`` file) necessary to run a grpc server.

In django-socio-grpc, proto files are generated from  from a service that has a ``serializer_class`` attribute (mapped to a ``ProtoSerializer`` class) and inherits from a mixin that automatically generates grpc_actions (see see :ref:`Generic Mixins <Generic Mixins>`)

You can also generate proto files from ``grpc_action`` request / response contents (see :ref:`grpc action <grpc_action>`).

In order to generate these files and its contents, there is a django command to run whenever you add a ``grpc_action`` or modify your request / response

Usage
-----
.. code-block:: bash

    python manage.py generateproto


.. list-table:: Options Available:
    :widths: 15 10 30 45
    :header-rows: 1

    * - Option
     - Shortcut
     - Default value
     - Description
    * - --project   
      - -p   
      - Use DJANGO_SETTINGS_MODULE first folder 
      - Name of the django project that is use in the proto package name.
    * - --dry-run    
      - -dr    
      - False    
      - Print in terminal the protofile content without writing it to a file or generate new python code.
    * - --no-generate-pb2   
      - -nopb2    
      - False    
      - Avoid generating python file. Only proto.
    * - --check    
      - -c    
      - False    
      - Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models. 
    * - --custom-verbose    
      - -cv
      - 0    
      - Number from 1 to 4 indicating the verbose level of the generation. 
    * - --directory    
      - -d 
      - None
      - Directory where the proto files will be generated. Default will be in the apps directories



Example
-------

.. code-block:: python

    # quickstart/models.py
    from django.db import models


    class User(models.Model):
        full_name = models.CharField(max_length=70)

        def __str__(self):
            return self.full_name

    # quickstart/serializers.py
    from django_socio_grpc import proto_serializers
    from rest_framework import serializers
    from quickstart.models import User, Post, Comment


    class UserProtoSerializer(proto_serializers.ModelProtoSerializer):
        # This line is written here as an example,
        # but can be removed as the serializer integrates all the fields in the model
        full_name = serializers.CharField(allow_blank=True)
        class Meta:
            model = User
            fields = "__all__"

    # Service
    from django_socio_grpc import generics
    from django_socio_grpc.decorators import grpc_action
    from ..models import User
    from ..serializers import UserProtoSerializer

    # inherits from AsyncModelService, therefore will register all default CRUD actions.
    class UserService(generics.AsyncModelService):
        queryset = User.objects.all()
        serializer_class = UserProtoSerializer

        @grpc_action
        async def SomeCustomMethod(
            request=[{"name": "foo", "type": "string"}],
            response=[{"name": "bar", "type": "string"}],
            response_stream=True
        ):
            # logic here
            pass

At the root of your project, run:

.. code-block:: bash

    python manage.py generateproto

If command executed successfully, you will see inside your user app, a grpc folder with two .py files, (``user_pb2.py`` and ``user_pb2_grpc.py``)
and a ``user.proto`` file. ``user.proto`` file should contain these lines:

.. code-block:: proto

    syntax = "proto3";

    package doc_example.generate_proto_doc;

    import "google/protobuf/empty.proto";

    service UserController {
        rpc List(UserListRequest) returns (UserListResponse) {}
        rpc Create(UserRequest) returns (UserResponse) {}
        rpc Retrieve(UserRetrieveRequest) returns (UserResponse) {}
        rpc Update(UserRequest) returns (UserResponse) {}
        rpc Destroy(UserDestroyRequest) returns (google.protobuf.Empty) {}
        rpc SomeCustomMethod(SomeCustomMethodRequest) returns (stream SomeCustomMethodResponse) {}
    }

    message UserResponse {
        string id = 1;
        string full_name = 2;
    }

    message UserListRequest {
    }

    message UserListResponse {
        repeated UserResponse results = 1;
    }

    message UserRequest {
        string id = 1;
        string full_name = 2;
    }

    message UserRetrieveRequest {
        string id = 1;
    }

    message UserDestroyRequest {
        string id = 1;
    }

    message SomeCustomMethodRequest {
        string foo = 1;
    }

    message SomeCustomMethodResponse {
        string bar = 1;
    }


Note: these files are meant for read only purposes, you can use the .proto file as a reference to verify wether
or not your serializer fields were correctly mapped but you should not try to modify them manually.

## Force message for know method

You can use `grpc_action` decorator on know method to override default message.

```python
class SomethingService(generics.AsyncModelService):
    queryset = SpecialFieldsModel.objects.all().order_by("uuid")
    serializer_class = SpecialFieldsModelSerializer

    @grpc_action(
        request=[{"name": "thing", "type": "string"}],
        response=[{"name": "anything", "type": "string"}],
    )
    async def Retrieve(self, request, context):
        pass
```

Generate:

```proto

import "google/protobuf/empty.proto";

service SomethingController {
    ...
    rpc Retrieve(SomethingRetrieveRequest) returns (SomethingRetrieveResponse) {}
    ...
}

...

message SomethingRetrieveRequest {
    string thing = 1;
}

message SomethingRetrieveResponse {
    string anything = 1;
}

...
```

## Read Only and write only props

If the settings `SEPARATE_READ_WRITE_MODEL` is true. Django Socio gRPC will automatically use read_only and write_only field kwargs to generate field only in request or response message.
This is also true for django field with specific value (editable=False or similar)

Example:

```python
class BasicServiceSerializer(proto_serializers.ProtoSerializer):

    user_name = serializers.CharField(read_only=True)
    email = serializers.CharField()
    password = serializers.CharField(write_only=True)

    class Meta:
        fields = ["user_name", "email", "password"]
```

Generate a message like:

```proto
message BasicServiceRequest {
    string user_name = 1;
    string password = 2;
}

message BasicServiceResponse {
    string user_name = 1;
    string email = 2;
}
```

## Nested serializer

Django Socio gRPC support nested serializer without no extra work. Just try it.

```python
class RelatedFieldModelSerializer(proto_serializers.ModelProtoSerializer):
    foreign_obj = ForeignModelSerializer(read_only=True)
    many_many_obj = ManyManyModelSerializer(read_only=True, many=True)

    class Meta:
        model = RelatedFieldModel
        fields = ["uuid", "foreign_obj", "many_many_obj"]
```

```proto
message RelatedFieldModelResponse {
    string uuid = 1;
    ForeignModelResponse foreign_obj = 2;
    repeated ManyManyModelResponse many_many_obj = 3;
}
```

## Special case of BaseProtoSerializer

As BaseProtoSerializer doesn't have fields but only to_representation and to_internal_value we can't automatically instropect code to find the correct proto type.

To address this issue you have to manually declare the name and protobuf type of the BaseProtoSerializer in a `to_proto_message` method.

This `to_proto_message` need to return a list of dict in the same format that `grpc_action` request or response as list input.

```python
class BaseProtoExampleSerializer(proto_serializers.BaseProtoSerializer):
    def to_representation(self, el):
        return {
            "uuid": str(el.uuid),
            "number_of_elements": el.number_of_elements,
            "is_archived": el.is_archived,
        }

    def to_proto_message(self):
        return [
            {"name": "uuid", "type": "string"},
            {"name": "number_of_elements", "type": "int32"},
            {"name": "is_archived", "type": "bool"},
        ]
```

```proto
message BaseProtoExampleResponse {
    string uuid = 1;
    int32 number_of_elements = 2;
    bool is_archived = 3;
}
```

## Special case of MethodSerializerField

DRF MethodSerializerField class is a field type that return the result of a method. So there is no possibility to automatically find the type of this field.
To contourn this problem Django Socio gRPC introduce function introspection where we are looking for return annotation in the method to find the prototype

```python
from typing import List, Disct

class ExampleSerializer(
    proto_serializers.ProtoSerializer
):

    default_method_field = serializers.SerializerMethodField()
    custom_method_field = serializers.SerializerMethodField(method_name="custom_method")

    def get_default_method_field(self, obj) -> int:
        return 3

    def custom_method(self, obj) -> List[Dict]:
        return [{"test": "test"}]

    class Meta:
        fields = ["default_method_field", "custom_method_field"]
```

```proto
message ExampleResponse {
    int32 default_method_field = 2;
    repeated google.protobuf.Struct custom_method_field = 3;
}
```


## Customizing the name of the field in the ListResponse

By default the name of the field used for list response is `results`. You can override it in the meta of your serializer:

```python
class ExampleSerializer(proto_serializers.ProtoSerializer):

    uuid = serializers.CharField()
    name = serializers.CharField()

    class Meta:
        message_list_attr = "list_custom_field_name"
        fields = ["uuid", "name"]

```

```proto
message ExampleResponse {
    string uuid = 1;
    string name = 2;
}

message ExampleListResponse {
    repeated ExampleResponse list_custom_field_name = 1;
    int32 count = 2;
}
```


## Add comments to fields

You could specify comments for fields in your model (proto message) via `help_text` attribute and `django_socio_grpc.utils.tools.ProtoComment` class:

```python
class ExampleSerializer(proto_serializers.ProtoSerializer):

    name = serializers.CharField(help_text=ProtoComment(["Comment for the name field"]))
    value = serializers.CharField(help_text=ProtoComment(["Multiline comment", "for the value field"]))

    class Meta:
        fields = ["name", "value"]

```

```proto
message ExampleResponse {
    // Comment for the name field
    string name = 1;
    // Multiline comment
    // for the value field
    string value = 2;
}
```