{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Socio gRPC Documentation Learn how to use gRPC with Django like you usually code with Django Rest Framework. What is Django Socio gRPC Django Socio gRPC is the implementation of how to do gRPC in a django web serveur in the Django Rest Framework way. This project is strongly inspired from Django gRPC Framework but add all the necessary features to be production ready such as pagination, filtering, async, authentification, ... And some really cool helper as the protobuf generation from the model or the register helper. Quickstart Install dependencies pip install django-socio-grpc Django setup django-admin startproject tutorial cd tutorial django-admin startapp quickstart python manage.py migrate Django settings Add django_socio_grpc and you new quickstart app to INSTALLED_APPS, settings module is in tutorial/settings.py: INSTALLED_APPS = [ ... 'django_socio_grpc', 'quickstart' ] Define a model # quickstart/models.py from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') Define a Serializer # quickstart/serializers.py from django_socio_grpc import proto_serializers from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question fields = [\"id\", \"question_text\", \"pub_date\"] Define a Service # quickstart/services.py from django_socio_grpc import generics from .models import Question from .serializers import QuestionProtoSerializer class QuestionService(generics.AsyncModelService): queryset = Question.objects.all() serializer_class = QuestionProtoSerializer Register the service # quickstart/handlers.py from django_socio_grpc.services.app_handler_registry import AppHandlerRegistry from quickstart.services import QuestionService def grpc_handlers(server): app_registry = AppHandlerRegistry(\"quickstart\", server) app_registry.register(QuestionService) This Handler will be the entrypoint for the service registration. Set its path as the ROOT_HANDLERS_HOOK of the GRPC_FRAMEWORK settings # tutorial/settings.py ... GRPC_FRAMEWORK = { \"ROOT_HANDLERS_HOOK\" : 'quickstart.handlers.grpc_handlers' } Generate the protofile and the client associated to the model python manage.py generateproto Assign the newly generated class to the serializer # quickstart/serializers.py from django_socio_grpc import proto_serializers import quickstart.grpc.quickstart_pb2 as quickstart_pb2 from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question proto_class = quickstart_pb2.QuestionResponse # Modification here proto_class_list = quickstart_pb2.QuestionListResponse # Modification here fields = [\"id\", \"question_text\", \"pub_date\"] Launch the server python manage.py grpcrunaioserver --dev","title":"Home"},{"location":"#django-socio-grpc-documentation","text":"Learn how to use gRPC with Django like you usually code with Django Rest Framework.","title":"Django Socio gRPC Documentation"},{"location":"#what-is-django-socio-grpc","text":"Django Socio gRPC is the implementation of how to do gRPC in a django web serveur in the Django Rest Framework way. This project is strongly inspired from Django gRPC Framework but add all the necessary features to be production ready such as pagination, filtering, async, authentification, ... And some really cool helper as the protobuf generation from the model or the register helper.","title":"What is Django Socio gRPC"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#install-dependencies","text":"pip install django-socio-grpc","title":"Install dependencies"},{"location":"#django-setup","text":"django-admin startproject tutorial cd tutorial django-admin startapp quickstart python manage.py migrate","title":"Django setup"},{"location":"#django-settings","text":"Add django_socio_grpc and you new quickstart app to INSTALLED_APPS, settings module is in tutorial/settings.py: INSTALLED_APPS = [ ... 'django_socio_grpc', 'quickstart' ]","title":"Django settings"},{"location":"#define-a-model","text":"# quickstart/models.py from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')","title":"Define a model"},{"location":"#define-a-serializer","text":"# quickstart/serializers.py from django_socio_grpc import proto_serializers from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question fields = [\"id\", \"question_text\", \"pub_date\"]","title":"Define a Serializer"},{"location":"#define-a-service","text":"# quickstart/services.py from django_socio_grpc import generics from .models import Question from .serializers import QuestionProtoSerializer class QuestionService(generics.AsyncModelService): queryset = Question.objects.all() serializer_class = QuestionProtoSerializer","title":"Define a Service"},{"location":"#register-the-service","text":"# quickstart/handlers.py from django_socio_grpc.services.app_handler_registry import AppHandlerRegistry from quickstart.services import QuestionService def grpc_handlers(server): app_registry = AppHandlerRegistry(\"quickstart\", server) app_registry.register(QuestionService) This Handler will be the entrypoint for the service registration. Set its path as the ROOT_HANDLERS_HOOK of the GRPC_FRAMEWORK settings # tutorial/settings.py ... GRPC_FRAMEWORK = { \"ROOT_HANDLERS_HOOK\" : 'quickstart.handlers.grpc_handlers' }","title":"Register the service"},{"location":"#generate-the-protofile-and-the-client-associated-to-the-model","text":"python manage.py generateproto","title":"Generate the protofile and the client associated to the model"},{"location":"#assign-the-newly-generated-class-to-the-serializer","text":"# quickstart/serializers.py from django_socio_grpc import proto_serializers import quickstart.grpc.quickstart_pb2 as quickstart_pb2 from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question proto_class = quickstart_pb2.QuestionResponse # Modification here proto_class_list = quickstart_pb2.QuestionListResponse # Modification here fields = [\"id\", \"question_text\", \"pub_date\"]","title":"Assign the newly generated class to the serializer"},{"location":"#launch-the-server","text":"python manage.py grpcrunaioserver --dev","title":"Launch the server"},{"location":"generate_proto/","text":"Proto Generation To be able to generate proto you need to register your service first. To do so please refer to https://socotecio.github.io/django-socio-grpc/server_and_service_register/#service-registration Command To automatically generate proto and python files use the generateproto command: python manage.py generateproto Options Available: Option Shortcut Default value Description --project -p Use DJANGO_SETTINGS_MODULE first folder Name of the django project that is use in the proto package name. --dry-run -dr False Print in terminal the protofile content without writing it to a file or generate new python code. --generate-python -gp True Generate python file same time you generate proto file. --check -c False Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models. Settings configuration As all the services are register at the launch of the server and not at the command level if we want to customize some behavior in the register process we need to use django settings. Setting Default value Description GRPC_FRAMEWORK.SEPARATE_READ_WRITE_MODEL True use the field fonctionnality read_only and write_only to seperate request message and response message. For all the following example we will show result with default value of settings. Default generation By default each service registered inheriting from know mixins will generate the default method and message in proto file. For example if we have a service that inherit from AsyncModelService and serializer like this: # Serializer from django_socio_grpc import proto_serializers from .models import Something class SomethingProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Something fields = [\"uuid\", \"start_date\", \"rate\"] # Service from django_socio_grpc import generics from ..models import Something from ..serializers import SomethingProtoSerializer class SomethingService(generics.AsyncModelService): queryset = Something.objects.all() serializer_class = SomethingProtoSerializer this will generate a proto like: syntax = \"proto3\"; package doc_example.generate_proto_doc; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(SomethingRequest) returns (SomethingResponse) {} rpc Retrieve(SomethingRetrieveRequest) returns (SomethingResponse) {} rpc Update(SomethingRequest) returns (SomethingResponse) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message SomethingResponse { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated SomethingResponse results = 1; } message SomethingRequest { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; } To see more complex usage without reading the doc please look at the code used for the unit tests: See services example used for test here See serializers example used for test here Adding Custom method (Decorator) You can add custome method (one not listed in mixins file: List, Create, Update, PartialUpdate, Retrieve, Delete, Stream) with the decorator grpc_action This decorator signature is: def grpc_action(request=None, response=None, request_name=None, response_name=None, request_stream=False, response_stream=False, use_request_list=False, use_response_list=False) Request and Response arg request and response are the variable used to define the field in the request/response proto message. It can be a string, a list of dict or a serializer. 1.String format Inject directly the string as message. Usefull if you want to use a already declared custom message or some specific type like google.protobuf.Empty . 2.List of dict format Transform the dict inside the list into proto field. Usefull if you have only 1 or 2 field and doesn't want to create a serializer Dict format is: { \"name\": \"field_name\", \"type\": \"existing_protobuf_type\" } 3.Serializer Use a Serializer class to create the proto message in the same way that it work for know method. Example: class BasicServiceSerializer(proto_serializers.ProtoSerializer): user_name = serializers.CharField() user_data = serializers.DictField() class Meta: fields = [\"user_name\", \"user_data\"] class BasicService(generics.GenericService): @grpc_action( request=[{\"name\": \"user_name\", \"type\": \"string\"}], response=BasicServiceSerializer, ) async def FetchDataForUser(self, request, context): pass Generate: service BasicController { rpc FetchDataForUser(BasicFetchDataForUserRequest) returns (BasicServiceResponse) {} } message BasicFetchDataForUserRequest { string user_name = 1; } message BasicServiceResponse { string user_name = 1; google.protobuf.Struct user_data = 2; } request_name and response_name arg Used to force a name for the message used. request_stream and response_stream arg Used to mark the request or the response as a stream in the protobuf file use_request_list and use_response_list arg Used to encapsulate the message inside a List message. You need to use it if you return a serializer message with many=True at initialisation Force message for know method You can use grpc_action decorator on know method to override default message. class SomethingService(generics.AsyncModelService): queryset = SpecialFieldsModel.objects.all().order_by(\"uuid\") serializer_class = SpecialFieldsModelSerializer @grpc_action( request=[{\"name\": \"thing\", \"type\": \"string\"}], response=[{\"name\": \"anything\", \"type\": \"string\"}], ) async def Retrieve(self, request, context): pass Generate: import \"google/protobuf/empty.proto\"; service SomethingController { ... rpc Retrieve(SomethingRetrieveRequest) returns (SomethingRetrieveResponse) {} ... } ... message SomethingRetrieveRequest { string thing = 1; } message SomethingRetrieveResponse { string anything = 1; } ... Read Only and write only props If the settings SEPARATE_READ_WRITE_MODEL is true. Django Socio gRPC will automatically use read_only and write_only field kwargs to generate field only in request or response message. This is also true for django field with specific value (editable=False or similar) Example: class BasicServiceSerializer(proto_serializers.ProtoSerializer): user_name = serializers.CharField(read_only=True) email = serializers.CharField() password = serializers.CharField(write_only=True) class Meta: fields = [\"user_name\", \"email\", \"password\"] Generate a message like: message BasicServiceRequest { string user_name = 1; string password = 2; } message BasicServiceResponse { string user_name = 1; string email = 2; } Nested serializer Django Socio gRPC support nested serializer without no extra work. Just try it. class RelatedFieldModelSerializer(proto_serializers.ModelProtoSerializer): foreign_obj = ForeignModelSerializer(read_only=True) many_many_obj = ManyManyModelSerializer(read_only=True, many=True) class Meta: model = RelatedFieldModel fields = [\"uuid\", \"foreign_obj\", \"many_many_obj\"] message RelatedFieldModelResponse { string uuid = 1; ForeignModelResponse foreign_obj = 2; repeated ManyManyModelResponse many_many_obj = 3; } Special case of BaseProtoSerializer As BaseProtoSerializer doesn't have fields but only to_representation and to_internal_value we can't automatically instropect code to find the correct proto type. To address this issue you have to manually declare the name and protobuf type of the BaseProtoSerializer in a to_proto_message method. This to_proto_message need to return a list of dict in the same format that grpc_action request or response as list input. class BaseProtoExampleSerializer(proto_serializers.BaseProtoSerializer): def to_representation(self, el): return { \"uuid\": str(el.uuid), \"number_of_elements\": el.number_of_elements, \"is_archived\": el.is_archived, } def to_proto_message(self): return [ {\"name\": \"uuid\", \"type\": \"string\"}, {\"name\": \"number_of_elements\", \"type\": \"int32\"}, {\"name\": \"is_archived\", \"type\": \"bool\"}, ] message BaseProtoExampleResponse { string uuid = 1; int32 number_of_elements = 2; bool is_archived = 3; } Special case of MethodSerializerField DRF MethodSerializerField class is a field type that return the result of a method. So there is no possibility to automatically find the type of this field. To contourn this problem Django Socio gRPC introduce function introspection where we are looking for return annotation in the method to find the prototype from typing import List, Disct class ExampleSerializer( proto_serializers.ProtoSerializer ): default_method_field = serializers.SerializerMethodField() custom_method_field = serializers.SerializerMethodField(method_name=\"custom_method\") def get_default_method_field(self, obj) -> int: return 3 def custom_method(self, obj) -> List[Dict]: return [{\"test\": \"test\"}] class Meta: fields = [\"default_method_field\", \"custom_method_field\"] message ExampleResponse { int32 default_method_field = 2; repeated google.protobuf.Struct custom_method_field = 3; } Customizing the name of the field in the ListResponse By default the name of the field used for list response is results . You can override it in the meta of your serializer: class ExampleSerializer(proto_serializers.ProtoSerializer): uuid = serializers.CharField() name = serializers.CharField() class Meta: message_list_attr = \"list_custom_field_name\" fields = [\"uuid\", \"name\"] message ExampleResponse { string uuid = 1; string name = 2; } message ExampleListResponse { repeated ExampleResponse list_custom_field_name = 1; int32 count = 2; } Add comments to fields You could specify comments for fields in your model (proto message) via help_text attribute and django_socio_grpc.utils.tools.ProtoComment class: class ExampleSerializer(proto_serializers.ProtoSerializer): name = serializers.CharField(help_text=ProtoComment([\"Comment for the name field\"])) value = serializers.CharField(help_text=ProtoComment([\"Multiline comment\", \"for the value field\"])) class Meta: fields = [\"name\", \"value\"] message ExampleResponse { // Comment for the name field string name = 1; // Multiline comment // for the value field string value = 2; }","title":"Generate Proto"},{"location":"generate_proto/#proto-generation","text":"To be able to generate proto you need to register your service first. To do so please refer to https://socotecio.github.io/django-socio-grpc/server_and_service_register/#service-registration","title":"Proto Generation"},{"location":"generate_proto/#command","text":"To automatically generate proto and python files use the generateproto command: python manage.py generateproto Options Available: Option Shortcut Default value Description --project -p Use DJANGO_SETTINGS_MODULE first folder Name of the django project that is use in the proto package name. --dry-run -dr False Print in terminal the protofile content without writing it to a file or generate new python code. --generate-python -gp True Generate python file same time you generate proto file. --check -c False Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models.","title":"Command"},{"location":"generate_proto/#settings-configuration","text":"As all the services are register at the launch of the server and not at the command level if we want to customize some behavior in the register process we need to use django settings. Setting Default value Description GRPC_FRAMEWORK.SEPARATE_READ_WRITE_MODEL True use the field fonctionnality read_only and write_only to seperate request message and response message. For all the following example we will show result with default value of settings.","title":"Settings configuration"},{"location":"generate_proto/#default-generation","text":"By default each service registered inheriting from know mixins will generate the default method and message in proto file. For example if we have a service that inherit from AsyncModelService and serializer like this: # Serializer from django_socio_grpc import proto_serializers from .models import Something class SomethingProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Something fields = [\"uuid\", \"start_date\", \"rate\"] # Service from django_socio_grpc import generics from ..models import Something from ..serializers import SomethingProtoSerializer class SomethingService(generics.AsyncModelService): queryset = Something.objects.all() serializer_class = SomethingProtoSerializer this will generate a proto like: syntax = \"proto3\"; package doc_example.generate_proto_doc; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(SomethingRequest) returns (SomethingResponse) {} rpc Retrieve(SomethingRetrieveRequest) returns (SomethingResponse) {} rpc Update(SomethingRequest) returns (SomethingResponse) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message SomethingResponse { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated SomethingResponse results = 1; } message SomethingRequest { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; } To see more complex usage without reading the doc please look at the code used for the unit tests: See services example used for test here See serializers example used for test here","title":"Default generation"},{"location":"generate_proto/#adding-custom-method-decorator","text":"You can add custome method (one not listed in mixins file: List, Create, Update, PartialUpdate, Retrieve, Delete, Stream) with the decorator grpc_action This decorator signature is: def grpc_action(request=None, response=None, request_name=None, response_name=None, request_stream=False, response_stream=False, use_request_list=False, use_response_list=False)","title":"Adding Custom method (Decorator)"},{"location":"generate_proto/#request-and-response-arg","text":"request and response are the variable used to define the field in the request/response proto message. It can be a string, a list of dict or a serializer. 1.String format Inject directly the string as message. Usefull if you want to use a already declared custom message or some specific type like google.protobuf.Empty . 2.List of dict format Transform the dict inside the list into proto field. Usefull if you have only 1 or 2 field and doesn't want to create a serializer Dict format is: { \"name\": \"field_name\", \"type\": \"existing_protobuf_type\" } 3.Serializer Use a Serializer class to create the proto message in the same way that it work for know method. Example: class BasicServiceSerializer(proto_serializers.ProtoSerializer): user_name = serializers.CharField() user_data = serializers.DictField() class Meta: fields = [\"user_name\", \"user_data\"] class BasicService(generics.GenericService): @grpc_action( request=[{\"name\": \"user_name\", \"type\": \"string\"}], response=BasicServiceSerializer, ) async def FetchDataForUser(self, request, context): pass Generate: service BasicController { rpc FetchDataForUser(BasicFetchDataForUserRequest) returns (BasicServiceResponse) {} } message BasicFetchDataForUserRequest { string user_name = 1; } message BasicServiceResponse { string user_name = 1; google.protobuf.Struct user_data = 2; }","title":"Request and Response arg"},{"location":"generate_proto/#request_name-and-response_name-arg","text":"Used to force a name for the message used.","title":"request_name and response_name arg"},{"location":"generate_proto/#request_stream-and-response_stream-arg","text":"Used to mark the request or the response as a stream in the protobuf file","title":"request_stream and response_stream arg"},{"location":"generate_proto/#use_request_list-and-use_response_list-arg","text":"Used to encapsulate the message inside a List message. You need to use it if you return a serializer message with many=True at initialisation","title":"use_request_list and use_response_list arg"},{"location":"generate_proto/#force-message-for-know-method","text":"You can use grpc_action decorator on know method to override default message. class SomethingService(generics.AsyncModelService): queryset = SpecialFieldsModel.objects.all().order_by(\"uuid\") serializer_class = SpecialFieldsModelSerializer @grpc_action( request=[{\"name\": \"thing\", \"type\": \"string\"}], response=[{\"name\": \"anything\", \"type\": \"string\"}], ) async def Retrieve(self, request, context): pass Generate: import \"google/protobuf/empty.proto\"; service SomethingController { ... rpc Retrieve(SomethingRetrieveRequest) returns (SomethingRetrieveResponse) {} ... } ... message SomethingRetrieveRequest { string thing = 1; } message SomethingRetrieveResponse { string anything = 1; } ...","title":"Force message for know method"},{"location":"generate_proto/#read-only-and-write-only-props","text":"If the settings SEPARATE_READ_WRITE_MODEL is true. Django Socio gRPC will automatically use read_only and write_only field kwargs to generate field only in request or response message. This is also true for django field with specific value (editable=False or similar) Example: class BasicServiceSerializer(proto_serializers.ProtoSerializer): user_name = serializers.CharField(read_only=True) email = serializers.CharField() password = serializers.CharField(write_only=True) class Meta: fields = [\"user_name\", \"email\", \"password\"] Generate a message like: message BasicServiceRequest { string user_name = 1; string password = 2; } message BasicServiceResponse { string user_name = 1; string email = 2; }","title":"Read Only and write only props"},{"location":"generate_proto/#nested-serializer","text":"Django Socio gRPC support nested serializer without no extra work. Just try it. class RelatedFieldModelSerializer(proto_serializers.ModelProtoSerializer): foreign_obj = ForeignModelSerializer(read_only=True) many_many_obj = ManyManyModelSerializer(read_only=True, many=True) class Meta: model = RelatedFieldModel fields = [\"uuid\", \"foreign_obj\", \"many_many_obj\"] message RelatedFieldModelResponse { string uuid = 1; ForeignModelResponse foreign_obj = 2; repeated ManyManyModelResponse many_many_obj = 3; }","title":"Nested serializer"},{"location":"generate_proto/#special-case-of-baseprotoserializer","text":"As BaseProtoSerializer doesn't have fields but only to_representation and to_internal_value we can't automatically instropect code to find the correct proto type. To address this issue you have to manually declare the name and protobuf type of the BaseProtoSerializer in a to_proto_message method. This to_proto_message need to return a list of dict in the same format that grpc_action request or response as list input. class BaseProtoExampleSerializer(proto_serializers.BaseProtoSerializer): def to_representation(self, el): return { \"uuid\": str(el.uuid), \"number_of_elements\": el.number_of_elements, \"is_archived\": el.is_archived, } def to_proto_message(self): return [ {\"name\": \"uuid\", \"type\": \"string\"}, {\"name\": \"number_of_elements\", \"type\": \"int32\"}, {\"name\": \"is_archived\", \"type\": \"bool\"}, ] message BaseProtoExampleResponse { string uuid = 1; int32 number_of_elements = 2; bool is_archived = 3; }","title":"Special case of BaseProtoSerializer"},{"location":"generate_proto/#special-case-of-methodserializerfield","text":"DRF MethodSerializerField class is a field type that return the result of a method. So there is no possibility to automatically find the type of this field. To contourn this problem Django Socio gRPC introduce function introspection where we are looking for return annotation in the method to find the prototype from typing import List, Disct class ExampleSerializer( proto_serializers.ProtoSerializer ): default_method_field = serializers.SerializerMethodField() custom_method_field = serializers.SerializerMethodField(method_name=\"custom_method\") def get_default_method_field(self, obj) -> int: return 3 def custom_method(self, obj) -> List[Dict]: return [{\"test\": \"test\"}] class Meta: fields = [\"default_method_field\", \"custom_method_field\"] message ExampleResponse { int32 default_method_field = 2; repeated google.protobuf.Struct custom_method_field = 3; }","title":"Special case of MethodSerializerField"},{"location":"generate_proto/#customizing-the-name-of-the-field-in-the-listresponse","text":"By default the name of the field used for list response is results . You can override it in the meta of your serializer: class ExampleSerializer(proto_serializers.ProtoSerializer): uuid = serializers.CharField() name = serializers.CharField() class Meta: message_list_attr = \"list_custom_field_name\" fields = [\"uuid\", \"name\"] message ExampleResponse { string uuid = 1; string name = 2; } message ExampleListResponse { repeated ExampleResponse list_custom_field_name = 1; int32 count = 2; }","title":"Customizing the name of the field in the ListResponse"},{"location":"generate_proto/#add-comments-to-fields","text":"You could specify comments for fields in your model (proto message) via help_text attribute and django_socio_grpc.utils.tools.ProtoComment class: class ExampleSerializer(proto_serializers.ProtoSerializer): name = serializers.CharField(help_text=ProtoComment([\"Comment for the name field\"])) value = serializers.CharField(help_text=ProtoComment([\"Multiline comment\", \"for the value field\"])) class Meta: fields = [\"name\", \"value\"] message ExampleResponse { // Comment for the name field string name = 1; // Multiline comment // for the value field string value = 2; }","title":"Add comments to fields"},{"location":"generate_proto_old_way/","text":"Proto Generation Command To automatically generate proto and python files use the generateproto command: python manage.py generateproto Options Available: Option Shortcut Default value Description --app -a required / use model option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --model -m required / use app option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --file -f appName.grpc.appName.proto Path to the generated proto file. --project -p Directory name Name used to build the package name inside the proto file. --dry-run -dr False Print in terminal the protofile content without writing it to a file or generate new python code. --generate-python -gp True Generate python file same time you generate proto file. --check -c False Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models. Default generation By default each model generate the default viewset as proto file. It allow by default to match all the endpoint given by the generics.AsyncModelService or generics.ModelService classes. For example if we have a model like: from django.db import models class Something(models.Model): uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) start_date = models.DateField() rate = models.CharField(max_length=255, null=True, blank=True, verbose_name=_(\"Rate\")) this will generate a proto like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; } Customize proto generation See exemple used for test here It is possible to adapt the proto generation depending of your need. To customize your proto generation you need to override grpc_messages and grpc_methods attributes of the Meta class of the model: class Something(models.Model): ... class Meta: grpc_messages = {...} grpc_methods = {...} This two dictionnary will allow you to customize the messages and the methods generated by the command generate_proto by simply reconstruct the file from the data of the dict. To see the data format read the next two sections. Customize gRPC Messages Format grpc_messages attribute is a dict with the format: {[MessageName<String>]: FieldNames<Array<String>>} where: MessageName is the name of the message as it appear in the proto file (SomethingListRequest, SomethingListResponse...) FieldNames is an array of models field. We use django instrospection to find the correct type to display in the proto file Example if we want a message named SomethingSmall: class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingSmall\": [\"uuid\", \"start_date\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; } Specific FieldName Values There is two helper to help building message: - __all__ : Allow you to use all the fields of the model class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": \"__all__\"} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; string rate = 3; } __custom__[proto_type]__[field_name]__ : Allow to specify a name not existing in the model and specify its type. You can put everything you want it will be directly transformed into protobuf format without django instropection. Be carefull when you use it to match your serializer and if you use nested messages that the other message it already declared. class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": [\"uuid\", \"__custom__int32__counter__\", \"__custom__repeated string__last_rates__\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; int32 counter = 2; repeated string last_rates = 3; } Customize gRPC Methods Format grpc_methods attribute is a dict with the format {[MethodName<String>]: { request: Request<Object>, response: Response<Object>}} where Request and Response are object like: {message: MessageName<String>, is_stream: <Boolean>} This data are simply used to generate the line of the method specified by MethodName in the grpc controller. Example: class Something(models.Model): ... class Meta: grpc_methods = { \"StreamList\": { \"request\": {\"is_stream\": False, \"message\": \"SomethingListRequest\"}, \"response\": {\"is_stream\": True, \"message\": \"SomethingListStreamResponse\"}, }, } This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; service ForeignModelController { rpc StreamList(SomethingListRequest) returns (stream SomethingListStreamResponse) {} } This will crash you have not SomethingListRequest and SomethingListStreamResponse defined in the messages of the proto file. See the default generated message and methods Using default methods to simplify overwriting As seen in the first part of this page we have some default generation. But at soon as you overwrite grpc_methods or grpc_messages you loose all the default generation. Often you only want to add a custom field or doesn't want to rewrite the all things. For that you can use the mixins methods get_default_message and get_default_method like: class Something(models.Model): ... class Meta: grpc_messages = { **CreateModelMixin.get_default_message(\"Something\"), **ListModelMixin.get_default_message(\"Something\"), \"SomethingRetrieveRequestCustom\": [\"name\"], \"SomethingRetrieveResponseCustom\": [\"uuid\"], } grpc_methods = { **ListModelMixin.get_default_method(\"Something\"), \"Retrieve\": { \"request\": { \"is_stream\": False, \"message\": \"SomethingRetrieveRequestCustom\", }, \"response\": { \"is_stream\": False, \"message\": \"SomethingRetrieveResponseCustom\", }, }, } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequestCustom { string name = 1; } message SomethingRetrieveResponseCustom { string uuid = 1; } get_default_message and get_default_method exist for all the mixins: CreateModelMixin, ListModelMixin, StreamModelMixin, RetrieveModelMixin, UpdateModelMixin, PartialUpdateModelMixin, DestroyModelMixin. Same for the async model that just inherit from the sync models. You can also use mixins.get_default_grpc_methods and mixins.get_default_grpc_messages to simulate all the defautl configuration and overwrite it after: class Something(models.Model): ... class Meta: grpc_messages = { **get_default_grpc_messages(\"Something\"), \"Something\": [\"uuid\", \"start_date\", \"rate\", \"__custom__string__new_field__\"] } grpc_methods = { **get_default_grpc_methods(\"Something\"), } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; string new_filed = 4; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; }","title":"Proto Generation"},{"location":"generate_proto_old_way/#proto-generation","text":"","title":"Proto Generation"},{"location":"generate_proto_old_way/#command","text":"To automatically generate proto and python files use the generateproto command: python manage.py generateproto Options Available: Option Shortcut Default value Description --app -a required / use model option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --model -m required / use app option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --file -f appName.grpc.appName.proto Path to the generated proto file. --project -p Directory name Name used to build the package name inside the proto file. --dry-run -dr False Print in terminal the protofile content without writing it to a file or generate new python code. --generate-python -gp True Generate python file same time you generate proto file. --check -c False Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models.","title":"Command"},{"location":"generate_proto_old_way/#default-generation","text":"By default each model generate the default viewset as proto file. It allow by default to match all the endpoint given by the generics.AsyncModelService or generics.ModelService classes. For example if we have a model like: from django.db import models class Something(models.Model): uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) start_date = models.DateField() rate = models.CharField(max_length=255, null=True, blank=True, verbose_name=_(\"Rate\")) this will generate a proto like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; }","title":"Default generation"},{"location":"generate_proto_old_way/#customize-proto-generation","text":"See exemple used for test here It is possible to adapt the proto generation depending of your need. To customize your proto generation you need to override grpc_messages and grpc_methods attributes of the Meta class of the model: class Something(models.Model): ... class Meta: grpc_messages = {...} grpc_methods = {...} This two dictionnary will allow you to customize the messages and the methods generated by the command generate_proto by simply reconstruct the file from the data of the dict. To see the data format read the next two sections.","title":"Customize proto generation"},{"location":"generate_proto_old_way/#customize-grpc-messages","text":"","title":"Customize gRPC Messages"},{"location":"generate_proto_old_way/#format","text":"grpc_messages attribute is a dict with the format: {[MessageName<String>]: FieldNames<Array<String>>} where: MessageName is the name of the message as it appear in the proto file (SomethingListRequest, SomethingListResponse...) FieldNames is an array of models field. We use django instrospection to find the correct type to display in the proto file Example if we want a message named SomethingSmall: class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingSmall\": [\"uuid\", \"start_date\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; }","title":"Format"},{"location":"generate_proto_old_way/#specific-fieldname-values","text":"There is two helper to help building message: - __all__ : Allow you to use all the fields of the model class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": \"__all__\"} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; string rate = 3; } __custom__[proto_type]__[field_name]__ : Allow to specify a name not existing in the model and specify its type. You can put everything you want it will be directly transformed into protobuf format without django instropection. Be carefull when you use it to match your serializer and if you use nested messages that the other message it already declared. class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": [\"uuid\", \"__custom__int32__counter__\", \"__custom__repeated string__last_rates__\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; int32 counter = 2; repeated string last_rates = 3; }","title":"Specific FieldName Values"},{"location":"generate_proto_old_way/#customize-grpc-methods","text":"","title":"Customize gRPC Methods"},{"location":"generate_proto_old_way/#format_1","text":"grpc_methods attribute is a dict with the format {[MethodName<String>]: { request: Request<Object>, response: Response<Object>}} where Request and Response are object like: {message: MessageName<String>, is_stream: <Boolean>} This data are simply used to generate the line of the method specified by MethodName in the grpc controller. Example: class Something(models.Model): ... class Meta: grpc_methods = { \"StreamList\": { \"request\": {\"is_stream\": False, \"message\": \"SomethingListRequest\"}, \"response\": {\"is_stream\": True, \"message\": \"SomethingListStreamResponse\"}, }, } This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; service ForeignModelController { rpc StreamList(SomethingListRequest) returns (stream SomethingListStreamResponse) {} } This will crash you have not SomethingListRequest and SomethingListStreamResponse defined in the messages of the proto file. See the default generated message and methods","title":"Format"},{"location":"generate_proto_old_way/#using-default-methods-to-simplify-overwriting","text":"As seen in the first part of this page we have some default generation. But at soon as you overwrite grpc_methods or grpc_messages you loose all the default generation. Often you only want to add a custom field or doesn't want to rewrite the all things. For that you can use the mixins methods get_default_message and get_default_method like: class Something(models.Model): ... class Meta: grpc_messages = { **CreateModelMixin.get_default_message(\"Something\"), **ListModelMixin.get_default_message(\"Something\"), \"SomethingRetrieveRequestCustom\": [\"name\"], \"SomethingRetrieveResponseCustom\": [\"uuid\"], } grpc_methods = { **ListModelMixin.get_default_method(\"Something\"), \"Retrieve\": { \"request\": { \"is_stream\": False, \"message\": \"SomethingRetrieveRequestCustom\", }, \"response\": { \"is_stream\": False, \"message\": \"SomethingRetrieveResponseCustom\", }, }, } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequestCustom { string name = 1; } message SomethingRetrieveResponseCustom { string uuid = 1; } get_default_message and get_default_method exist for all the mixins: CreateModelMixin, ListModelMixin, StreamModelMixin, RetrieveModelMixin, UpdateModelMixin, PartialUpdateModelMixin, DestroyModelMixin. Same for the async model that just inherit from the sync models. You can also use mixins.get_default_grpc_methods and mixins.get_default_grpc_messages to simulate all the defautl configuration and overwrite it after: class Something(models.Model): ... class Meta: grpc_messages = { **get_default_grpc_messages(\"Something\"), \"Something\": [\"uuid\", \"start_date\", \"rate\", \"__custom__string__new_field__\"] } grpc_methods = { **get_default_grpc_methods(\"Something\"), } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; string new_filed = 4; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; }","title":"Using default methods to simplify overwriting"},{"location":"generic_service/","text":"Generic Service Django Socio gRPC use services instead of View of Viewset. Except for the name and the internal layer a Service work like a DRF Generic views . The generic services are class based service that allow you to reuse part of common logic between api. Same logic that DRF Generics views. If the generic services don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic services to compose your own set of reusable generic services. Examples from django.contrib.auth.models import User from myapp.serializers import UserProtoSerializer from django_socio_grpc import generics class UserListService(generics.ListCreateAPIView): queryset = User.objects.all() serializer_class = UserProtoSerializer","title":"Generic Service"},{"location":"generic_service/#generic-service","text":"Django Socio gRPC use services instead of View of Viewset. Except for the name and the internal layer a Service work like a DRF Generic views . The generic services are class based service that allow you to reuse part of common logic between api. Same logic that DRF Generics views. If the generic services don't suit the needs of your API, you can drop down to using the regular APIView class, or reuse the mixins and base classes used by the generic services to compose your own set of reusable generic services.","title":"Generic Service"},{"location":"generic_service/#examples","text":"from django.contrib.auth.models import User from myapp.serializers import UserProtoSerializer from django_socio_grpc import generics class UserListService(generics.ListCreateAPIView): queryset = User.objects.all() serializer_class = UserProtoSerializer","title":"Examples"},{"location":"logging/","text":"","title":"Logging"},{"location":"model_service/","text":"","title":"Model Service"},{"location":"permissions_and_authentication/","text":"","title":"Permissions and Authentication"},{"location":"proto_serializer/","text":"Proto Serializer Proto Serializer works exactly the same as DRF serializer . You juste have to inherit from a different class (see mapping under) and add two meta attr proto_class and proto_class_list . Mapping betwen Django REST Framework and Django Socio gRPC DRF Class DSG class rest_framework.serializers.BaseSerializer django_socio_grpc.proto_serializers.BaseProtoSerializer rest_framework.serializers.Serializer django_socio_grpc.proto_serializers.ProtoSerializer rest_framework.serializers.ListSerializer django_socio_grpc.proto_serializers.ListProtoSerializer rest_framework.serializers.ModelSerializer django_socio_grpc.proto_serializers.ModelProtoSerializer Example with ModelProtoSerializer Example will only focus on ModelProtoSerializer. First we will use again our Question model used in the quickstart: class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') Then we generate the proto file for this model. See Generate Proto You can now define your serializer like this: # quickstart/serializers.py from django_socio_grpc import proto_serializers import quickstart.grpc.quickstart_pb2 as quickstart_pb2 from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question proto_class = quickstart_pb2.Question proto_comment = ProtoComment([\"Multiline\", \"comment\", \"for\", \"message\"]) proto_class_list = quickstart_pb2.QuestionListResponse fields = [\"id\", \"question_text\", \"pub_date\"] proto_class and proto_class_list proto_class and proto_class_list will be used to convert incoming grpc message or python data into grpc messages. proto_class_list is used when the param many=True is passed to the serializer. It allow us to have 2 differents proto messages with the same models for list and retrieve methods in a ModelService If the message received in request is different than the one used in response then you will have to create 2 serializers. serializer.data vs serializer.message Django Socio gRPC support retro compatibility so serializer.data is still accessible and still in dictionnary format. However, it's recommended to use serializer.message that is in the gRPC message format and should always return serializer.message as response data. Extra kwargs options Extra kwargs options are used like this: serializer_instance = SerializerClass(**extra_kwras_options) stream <Boolean> : return the message as a list of proto_class instead of an instance of proto_class_list to be used in stream. See Stream exemple message_list_attr <String> : change the attribute name for the list of instance returned by a proto_class_list (default is results). proto_comment <ProtoComment or string> : add to model (message) comment in output PROTO file. ProtoComment class is declared in django_socio_grpc.utils.tools a helps to have multi-line comments. Tips for converting UUID Field If you use UUID you can came accross problem as this type is not automatically converted in string format when used as Foreign Key. To fix this please use pk_field : related_object = serializers.PrimaryKeyRelatedField( queryset=Something.objects.all(), pk_field=UUIDField(format=\"hex_verbose\"), ) Tips for converting empty string to None As gRPC always send the default value for type if not send some behavior of DRF like handling differently None value and empty string are not working. You can design your own system by adding arguments to adapt the behavior but if you have field where empty string mean None as for Datetime for example you can use code like this: from django_socio_grpc import proto_serializers from rest_framework.fields import DateTimeField from django.core.exceptions import ObjectDoesNotExist class NullableDatetimeField(DateTimeField): def to_internal_value(self, value): if not value: return None return super().to_internal_value() class ExampleProtoSerializer(proto_serializers.ModelProtoSerializer): example_datetime = NullableDatetimeField(validators=[]) class Meta: model = Example proto_class = example_pb2.Example proto_class_list = example_pb2.ExampleListResponse fields = \"__all__\"","title":"Proto Serializer"},{"location":"proto_serializer/#proto-serializer","text":"Proto Serializer works exactly the same as DRF serializer . You juste have to inherit from a different class (see mapping under) and add two meta attr proto_class and proto_class_list .","title":"Proto Serializer"},{"location":"proto_serializer/#mapping-betwen-django-rest-framework-and-django-socio-grpc","text":"DRF Class DSG class rest_framework.serializers.BaseSerializer django_socio_grpc.proto_serializers.BaseProtoSerializer rest_framework.serializers.Serializer django_socio_grpc.proto_serializers.ProtoSerializer rest_framework.serializers.ListSerializer django_socio_grpc.proto_serializers.ListProtoSerializer rest_framework.serializers.ModelSerializer django_socio_grpc.proto_serializers.ModelProtoSerializer","title":"Mapping betwen Django REST Framework and Django Socio gRPC"},{"location":"proto_serializer/#example-with-modelprotoserializer","text":"Example will only focus on ModelProtoSerializer. First we will use again our Question model used in the quickstart: class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') Then we generate the proto file for this model. See Generate Proto You can now define your serializer like this: # quickstart/serializers.py from django_socio_grpc import proto_serializers import quickstart.grpc.quickstart_pb2 as quickstart_pb2 from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question proto_class = quickstart_pb2.Question proto_comment = ProtoComment([\"Multiline\", \"comment\", \"for\", \"message\"]) proto_class_list = quickstart_pb2.QuestionListResponse fields = [\"id\", \"question_text\", \"pub_date\"]","title":"Example with ModelProtoSerializer"},{"location":"proto_serializer/#proto_class-and-proto_class_list","text":"proto_class and proto_class_list will be used to convert incoming grpc message or python data into grpc messages. proto_class_list is used when the param many=True is passed to the serializer. It allow us to have 2 differents proto messages with the same models for list and retrieve methods in a ModelService If the message received in request is different than the one used in response then you will have to create 2 serializers.","title":"proto_class and proto_class_list"},{"location":"proto_serializer/#serializerdata-vs-serializermessage","text":"Django Socio gRPC support retro compatibility so serializer.data is still accessible and still in dictionnary format. However, it's recommended to use serializer.message that is in the gRPC message format and should always return serializer.message as response data.","title":"serializer.data vs serializer.message"},{"location":"proto_serializer/#extra-kwargs-options","text":"Extra kwargs options are used like this: serializer_instance = SerializerClass(**extra_kwras_options) stream <Boolean> : return the message as a list of proto_class instead of an instance of proto_class_list to be used in stream. See Stream exemple message_list_attr <String> : change the attribute name for the list of instance returned by a proto_class_list (default is results). proto_comment <ProtoComment or string> : add to model (message) comment in output PROTO file. ProtoComment class is declared in django_socio_grpc.utils.tools a helps to have multi-line comments.","title":"Extra kwargs options"},{"location":"proto_serializer/#tips-for-converting-uuid-field","text":"If you use UUID you can came accross problem as this type is not automatically converted in string format when used as Foreign Key. To fix this please use pk_field : related_object = serializers.PrimaryKeyRelatedField( queryset=Something.objects.all(), pk_field=UUIDField(format=\"hex_verbose\"), )","title":"Tips for converting UUID Field"},{"location":"proto_serializer/#tips-for-converting-empty-string-to-none","text":"As gRPC always send the default value for type if not send some behavior of DRF like handling differently None value and empty string are not working. You can design your own system by adding arguments to adapt the behavior but if you have field where empty string mean None as for Datetime for example you can use code like this: from django_socio_grpc import proto_serializers from rest_framework.fields import DateTimeField from django.core.exceptions import ObjectDoesNotExist class NullableDatetimeField(DateTimeField): def to_internal_value(self, value): if not value: return None return super().to_internal_value() class ExampleProtoSerializer(proto_serializers.ModelProtoSerializer): example_datetime = NullableDatetimeField(validators=[]) class Meta: model = Example proto_class = example_pb2.Example proto_class_list = example_pb2.ExampleListResponse fields = \"__all__\"","title":"Tips for converting empty string to None"},{"location":"server_and_service_register/","text":"gRPC sever and services registration grpcrunserver && grpcrunaioserver As Django Socio gRPC use gRPC and so HTTP2 it use the grpc lib to launch the server and not wsgi or asgi. grpcrunserver is the django command launching a synchrone server and grpcrunaioserver the async server. For performance issue and Stream availability we recommend you to always use grpcrunaioserver Run a grpc server: python manage.py grpcrunaioserver Run a grpc development server, this tells Django to use the auto-reloader and run checks: python manage.py grpcrunaioserver --dev Run the server with a certain address: python manage.py grpcrunaioserver 127.0.0.1:8000 --max-workers 5 Service Registration To be able to serve endpoint we need to register our endpoint into the gRPC server for that we need a handler hook function. def grpc_handlers(server): ... Then we need to set the ROOT_HANDLERS_HOOK settings with the path to this handler method: GRPC_FRAMEWORK = { ... 'ROOT_HANDLERS_HOOK': 'path.to.your.grpc_handlers', } Once defined you need to register your service. To easily do that we provide a class helper, AppHandlerRegistry. It allow to register Services for a particular app. from django_socio_grpc.utils.servicer_register import AppHandlerRegistry from my_app_name.services.my_service import MyService def grpc_handlers(server): app_registry = AppHandlerRegistry(\"my_app_name\", server) app_registry.register(MyService) AppHandlerRegistry also support dynamic import by name but it can imply error as it expect to find the file to a correct location (by default <app_name>/services/<service_name>_service.py ) that can be changed with undocumented arguments: from django_socio_grpc.utils.servicer_register import AppHandlerRegistry def grpc_handlers(server): app_registry = AppHandlerRegistry(\"my_app_name\", server) app_registry.register(\"MyService\") To go deeper Under the hood AppHandlerRegistry register method will use the name of the app and the name of the service to import the correct method from the pb2_grpc file generated automatically by the generateproto command. This helper is also the entrypoint for the registration of the service for the proto generation. So even if you can use Django Socio gRPC without it the automatic registration and so the automatic proto generation will not work. Code snippet to explain how we use the function from the pb2_grpc file pb2_grpc = import_module( f\"{self.app_name}.{self.grpc_folder}.{self.app_name}_pb2_grpc\" ) controller_name = service_class.get_controller_name() add_server = getattr( pb2_grpc, f\"add_{controller_name}Servicer_to_server\" ) add_server(service_class.as_servicer(), self.server)","title":"Server and service register"},{"location":"server_and_service_register/#grpc-sever-and-services-registration","text":"","title":"gRPC sever and services registration"},{"location":"server_and_service_register/#grpcrunserver-grpcrunaioserver","text":"As Django Socio gRPC use gRPC and so HTTP2 it use the grpc lib to launch the server and not wsgi or asgi. grpcrunserver is the django command launching a synchrone server and grpcrunaioserver the async server. For performance issue and Stream availability we recommend you to always use grpcrunaioserver Run a grpc server: python manage.py grpcrunaioserver Run a grpc development server, this tells Django to use the auto-reloader and run checks: python manage.py grpcrunaioserver --dev Run the server with a certain address: python manage.py grpcrunaioserver 127.0.0.1:8000 --max-workers 5","title":"grpcrunserver &amp;&amp; grpcrunaioserver"},{"location":"server_and_service_register/#service-registration","text":"To be able to serve endpoint we need to register our endpoint into the gRPC server for that we need a handler hook function. def grpc_handlers(server): ... Then we need to set the ROOT_HANDLERS_HOOK settings with the path to this handler method: GRPC_FRAMEWORK = { ... 'ROOT_HANDLERS_HOOK': 'path.to.your.grpc_handlers', } Once defined you need to register your service. To easily do that we provide a class helper, AppHandlerRegistry. It allow to register Services for a particular app. from django_socio_grpc.utils.servicer_register import AppHandlerRegistry from my_app_name.services.my_service import MyService def grpc_handlers(server): app_registry = AppHandlerRegistry(\"my_app_name\", server) app_registry.register(MyService) AppHandlerRegistry also support dynamic import by name but it can imply error as it expect to find the file to a correct location (by default <app_name>/services/<service_name>_service.py ) that can be changed with undocumented arguments: from django_socio_grpc.utils.servicer_register import AppHandlerRegistry def grpc_handlers(server): app_registry = AppHandlerRegistry(\"my_app_name\", server) app_registry.register(\"MyService\")","title":"Service Registration"},{"location":"server_and_service_register/#to-go-deeper","text":"Under the hood AppHandlerRegistry register method will use the name of the app and the name of the service to import the correct method from the pb2_grpc file generated automatically by the generateproto command. This helper is also the entrypoint for the registration of the service for the proto generation. So even if you can use Django Socio gRPC without it the automatic registration and so the automatic proto generation will not work. Code snippet to explain how we use the function from the pb2_grpc file pb2_grpc = import_module( f\"{self.app_name}.{self.grpc_folder}.{self.app_name}_pb2_grpc\" ) controller_name = service_class.get_controller_name() add_server = getattr( pb2_grpc, f\"add_{controller_name}Servicer_to_server\" ) add_server(service_class.as_servicer(), self.server)","title":"To go deeper"},{"location":"settings/","text":"Settings You can specify settings in django settings module in such way: GRPC_FRAMEWORK = { \"ROOT_HANDLERS_HOOK\": \"__YOUR_PROJECT_NAME___.handlers.grpc_handlers\", \"SEPARATE_READ_WRITE_MODEL\": False, \"DEFAULT_AUTHENTICATION_CLASSES\": [ \"rest_framework.authentication.BasicAuthentication\", \"rest_framework.authentication.SessionAuthentication\", ], \"DEFAULT_PERMISSION_CLASSES\": [ \"rest_framework.permissions.DjangoModelPermissions\", ], \"MAP_METADATA_KEYS\": { \"HEADERS\": \"HEADERS\", \"PAGINATION\": \"PAGINATION\", \"FILTERS\": \"FILTERS\" }, } Authentication and permissions options It supports standard and Django REST frameworks authentications and permissions management. So feel free to specify DEFAULT_AUTHENTICATION_CLASSES and DEFAULT_PERMISSION_CLASSES as usually. Please read more in Permissions and authentication section. Metadata options Option MAP_METADATA_KEYS is not mandatory (in the example default value is shown) and allow to specify the place in gRPC metadata where to search headers, pagination and filters data. By default each type of data has appropriate metadata key where data is saved in JSON format. So, in case of Bearer authorization, you should specify HEADERS metadata item as such JSON value: {\"Authorization\": \"Bearer xxxxxx\", \"User-Agent\": \"for_example\"} It's default behaviour. If you would like to have each header in separate metadata item, you can omit HEADERS key in MAP_METADATA_KEYS option. Separate read write model option Option SEPARATE_READ_WRITE_MODEL allow to separate request message and response message in proto file (default is True).","title":"Settings"},{"location":"settings/#settings","text":"You can specify settings in django settings module in such way: GRPC_FRAMEWORK = { \"ROOT_HANDLERS_HOOK\": \"__YOUR_PROJECT_NAME___.handlers.grpc_handlers\", \"SEPARATE_READ_WRITE_MODEL\": False, \"DEFAULT_AUTHENTICATION_CLASSES\": [ \"rest_framework.authentication.BasicAuthentication\", \"rest_framework.authentication.SessionAuthentication\", ], \"DEFAULT_PERMISSION_CLASSES\": [ \"rest_framework.permissions.DjangoModelPermissions\", ], \"MAP_METADATA_KEYS\": { \"HEADERS\": \"HEADERS\", \"PAGINATION\": \"PAGINATION\", \"FILTERS\": \"FILTERS\" }, }","title":"Settings"},{"location":"settings/#authentication-and-permissions-options","text":"It supports standard and Django REST frameworks authentications and permissions management. So feel free to specify DEFAULT_AUTHENTICATION_CLASSES and DEFAULT_PERMISSION_CLASSES as usually. Please read more in Permissions and authentication section.","title":"Authentication and permissions options"},{"location":"settings/#metadata-options","text":"Option MAP_METADATA_KEYS is not mandatory (in the example default value is shown) and allow to specify the place in gRPC metadata where to search headers, pagination and filters data. By default each type of data has appropriate metadata key where data is saved in JSON format. So, in case of Bearer authorization, you should specify HEADERS metadata item as such JSON value: {\"Authorization\": \"Bearer xxxxxx\", \"User-Agent\": \"for_example\"} It's default behaviour. If you would like to have each header in separate metadata item, you can omit HEADERS key in MAP_METADATA_KEYS option.","title":"Metadata options"},{"location":"settings/#separate-read-write-model-option","text":"Option SEPARATE_READ_WRITE_MODEL allow to separate request message and response message in proto file (default is True).","title":"Separate read write model option"},{"location":"sync_vs_async/","text":"Sync vs Async Django Socio gRPC Framework actually support both async and sync mode for gRPC. gRPC AsyncIO API is the new version of gRPC Python whose architecture is tailored to AsyncIO. So its the recommended usage. The change are minor in the API but major in the underlying stack. It will allow you to handle way more requests in some case. Specifically if you use streaming where using it in sync mode can block your whole server. The Django Socio gRPC framework work the same in sync or async mode. But be carreful of some minor chnage in the import or in the Django ORM call. The different imports Async Class Sync class django_socio_grpc.mixins.AsyncCreateModelMixin django_socio_grpc.mixins.CreateModelMixin django_socio_grpc.mixins.AsyncListModelMixin django_socio_grpc.mixins.ListModelMixin django_socio_grpc.mixins.AsyncStreamModelMixin django_socio_grpc.mixins.StreamModelMixin django_socio_grpc.mixins.AsyncRetrieveModelMixin django_socio_grpc.mixins.RetrieveModelMixin django_socio_grpc.mixins.AsyncUpdateModelMixin django_socio_grpc.mixins.UpdateModelMixin django_socio_grpc.mixins.AsyncPartialUpdateModelMixin django_socio_grpc.mixins.PartialUpdateModelMixin django_socio_grpc.mixins.AsyncDestroyModelMixin django_socio_grpc.mixins.DestroyModelMixin --------------------- --------------------- django_socio_grpc.generics.AsyncCreateService django_socio_grpc.generics.CreateService django_socio_grpc.generics.AsyncListService django_socio_grpc.generics.ListService django_socio_grpc.generics.AsyncStreamService django_socio_grpc.generics.StreamService django_socio_grpc.generics.AsyncRetrieveService django_socio_grpc.generics.RetrieveService django_socio_grpc.generics.AsyncDestroyService django_socio_grpc.generics.DestroyService django_socio_grpc.generics.AsyncUpdateService django_socio_grpc.generics.UpdateService django_socio_grpc.generics.AsyncReadOnlyModelService django_socio_grpc.generics.ReadOnlyModelService django_socio_grpc.generics.AsyncModelService django_socio_grpc.generics.class ModelService( The usage of the django ORM The django ORM (in its verson <=4.0) is currenctly not supporing async request. This way you can't use orm methodes inside an async context. Fortunatly it exist wrapper from asgiref that allow you to wrap method sync method to use them in an async context. See example inside the mixins to understand it and use it in your project The gRPC API difference with Stream The main advantage to use async api is the use of not blocking stream. Indeed instead of using a generator as stream answer we can now read and write data from the context where we need to. The context is an instance of ServicerContext so for stream instance (methods defined as stream in the proto file) you have acess to read, write or both method depend on if you have your request, response or both marked as stream in the proto file.","title":"Sync vs Async"},{"location":"sync_vs_async/#sync-vs-async","text":"Django Socio gRPC Framework actually support both async and sync mode for gRPC. gRPC AsyncIO API is the new version of gRPC Python whose architecture is tailored to AsyncIO. So its the recommended usage. The change are minor in the API but major in the underlying stack. It will allow you to handle way more requests in some case. Specifically if you use streaming where using it in sync mode can block your whole server. The Django Socio gRPC framework work the same in sync or async mode. But be carreful of some minor chnage in the import or in the Django ORM call.","title":"Sync vs Async"},{"location":"sync_vs_async/#the-different-imports","text":"Async Class Sync class django_socio_grpc.mixins.AsyncCreateModelMixin django_socio_grpc.mixins.CreateModelMixin django_socio_grpc.mixins.AsyncListModelMixin django_socio_grpc.mixins.ListModelMixin django_socio_grpc.mixins.AsyncStreamModelMixin django_socio_grpc.mixins.StreamModelMixin django_socio_grpc.mixins.AsyncRetrieveModelMixin django_socio_grpc.mixins.RetrieveModelMixin django_socio_grpc.mixins.AsyncUpdateModelMixin django_socio_grpc.mixins.UpdateModelMixin django_socio_grpc.mixins.AsyncPartialUpdateModelMixin django_socio_grpc.mixins.PartialUpdateModelMixin django_socio_grpc.mixins.AsyncDestroyModelMixin django_socio_grpc.mixins.DestroyModelMixin --------------------- --------------------- django_socio_grpc.generics.AsyncCreateService django_socio_grpc.generics.CreateService django_socio_grpc.generics.AsyncListService django_socio_grpc.generics.ListService django_socio_grpc.generics.AsyncStreamService django_socio_grpc.generics.StreamService django_socio_grpc.generics.AsyncRetrieveService django_socio_grpc.generics.RetrieveService django_socio_grpc.generics.AsyncDestroyService django_socio_grpc.generics.DestroyService django_socio_grpc.generics.AsyncUpdateService django_socio_grpc.generics.UpdateService django_socio_grpc.generics.AsyncReadOnlyModelService django_socio_grpc.generics.ReadOnlyModelService django_socio_grpc.generics.AsyncModelService django_socio_grpc.generics.class ModelService(","title":"The different imports"},{"location":"sync_vs_async/#the-usage-of-the-django-orm","text":"The django ORM (in its verson <=4.0) is currenctly not supporing async request. This way you can't use orm methodes inside an async context. Fortunatly it exist wrapper from asgiref that allow you to wrap method sync method to use them in an async context. See example inside the mixins to understand it and use it in your project","title":"The usage of the django ORM"},{"location":"sync_vs_async/#the-grpc-api-difference-with-stream","text":"The main advantage to use async api is the use of not blocking stream. Indeed instead of using a generator as stream answer we can now read and write data from the context where we need to. The context is an instance of ServicerContext so for stream instance (methods defined as stream in the proto file) you have acess to read, write or both method depend on if you have your request, response or both marked as stream in the proto file.","title":"The gRPC API difference with Stream"},{"location":"testing/","text":"","title":"Testing"}]}