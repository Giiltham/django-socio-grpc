{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Socio gRPC Documentation Learn how to use gRPC with Django like you usually code with Django Rest Framework. What is Django Socio gRPC Django Socio gRPC is the implementation of how to do gRPC in a django web serveur in the Django Rest Framework way. This project is strongly inspired from Django gRPC Framework but add all the necessary features to be production ready such as pagination, filtering, async, authentification, ... And some really cool helper as the protobuf generation from the model or the register helper. Quickstart Install dependencies pip install djangogrpcframework pip install django pip install grpcio pip install grpcio-tools pip install asyncio # Not mandatory but it's the default behavior used in the quickstart pip install django-socio-grpc Django setup django-admin startproject tutorial cd tutorial django-admin startapp quickstart python manage.py migrate Django settings Add django_socio_grpc to INSTALLED_APPS, settings module is in tutorial/settings.py: INSTALLED_APPS = [ ... 'django_socio_grpc', ] Define a model # quickstart/models.py from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') Generate the protofile and the client associated to the model python manage.py generateproto --app quickstart Define a Serializer # quickstart/serializers.py from django_socio_grpc import proto_serializers import quickstart.grpc.quickstart_pb2 as quickstart_pb2 from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question proto_class = quickstart_pb2.Question proto_class_list = quickstart_pb2.QuestionListResponse fields = [\"id\", \"question_text\", \"pub_date\"] Define a Service # quickstart/services.py from django_socio_grpc import generics from .models import Question from .serializers import QuestionProtoSerializer class QuestionService(generics.AsyncModelService): queryset = Question.objects.all() serializer_class = QuestionProtoSerializer Register the service # quickstart/handlers.py from django_socio_grpc.utils.servicer_register import AppHandlerRegistry def grpc_handlers(server): app_registry = AppHandlerRegistry(\"quickstart\", server) app_registry.register(\"Question\") Launch the server python manage.py grpcrunaioserver --dev","title":"Home"},{"location":"#django-socio-grpc-documentation","text":"Learn how to use gRPC with Django like you usually code with Django Rest Framework.","title":"Django Socio gRPC Documentation"},{"location":"#what-is-django-socio-grpc","text":"Django Socio gRPC is the implementation of how to do gRPC in a django web serveur in the Django Rest Framework way. This project is strongly inspired from Django gRPC Framework but add all the necessary features to be production ready such as pagination, filtering, async, authentification, ... And some really cool helper as the protobuf generation from the model or the register helper.","title":"What is Django Socio gRPC"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#install-dependencies","text":"pip install djangogrpcframework pip install django pip install grpcio pip install grpcio-tools pip install asyncio # Not mandatory but it's the default behavior used in the quickstart pip install django-socio-grpc","title":"Install dependencies"},{"location":"#django-setup","text":"django-admin startproject tutorial cd tutorial django-admin startapp quickstart python manage.py migrate","title":"Django setup"},{"location":"#django-settings","text":"Add django_socio_grpc to INSTALLED_APPS, settings module is in tutorial/settings.py: INSTALLED_APPS = [ ... 'django_socio_grpc', ]","title":"Django settings"},{"location":"#define-a-model","text":"# quickstart/models.py from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')","title":"Define a model"},{"location":"#generate-the-protofile-and-the-client-associated-to-the-model","text":"python manage.py generateproto --app quickstart","title":"Generate the protofile and the client associated to the model"},{"location":"#define-a-serializer","text":"# quickstart/serializers.py from django_socio_grpc import proto_serializers import quickstart.grpc.quickstart_pb2 as quickstart_pb2 from .models import Question class QuestionProtoSerializer(proto_serializers.ModelProtoSerializer): class Meta: model = Question proto_class = quickstart_pb2.Question proto_class_list = quickstart_pb2.QuestionListResponse fields = [\"id\", \"question_text\", \"pub_date\"]","title":"Define a Serializer"},{"location":"#define-a-service","text":"# quickstart/services.py from django_socio_grpc import generics from .models import Question from .serializers import QuestionProtoSerializer class QuestionService(generics.AsyncModelService): queryset = Question.objects.all() serializer_class = QuestionProtoSerializer","title":"Define a Service"},{"location":"#register-the-service","text":"# quickstart/handlers.py from django_socio_grpc.utils.servicer_register import AppHandlerRegistry def grpc_handlers(server): app_registry = AppHandlerRegistry(\"quickstart\", server) app_registry.register(\"Question\")","title":"Register the service"},{"location":"#launch-the-server","text":"python manage.py grpcrunaioserver --dev","title":"Launch the server"},{"location":"generate_proto/","text":"Proto Generation Command To automatically generate proto and python files use the generateproto command: python manage.py generateproto Options Available: Option Shortcut Default value Description --app -a required / use model option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --model -m required / use app option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --file -f appName.grpc.appName.proto Path to the generated proto file. --project -p Directory name Name used to build the package name inside the proto file. --dry-run -dr False Print in terminal the protofile content without writing it to a file or generate new python code. --generate-python -gp True Generate python file same time you generate proto file. --check -c False Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models. Default generation By default each model generate the default viewset as proto file. It allow by default to match all the endpoint given by the generics.AsyncModelService or generics.ModelService classes. For example if we have a model like: class Something(models.Model): uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) start_date = models.DateField() rate = models.CharField(max_length=255, null=True, blank=True, verbose_name=_(\"Rate\")) this will generate a proto like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; } Customize proto generation See exemple used for test here It is possible to adapt the proto generation depending of your need. To customize your proto generation you need to override grpc_messages and grpc_methods attributes of the Meta class of the model: class Something(models.Model): ... class Meta: grpc_messages = {...} grpc_methods = {...} This two dictionnary will allow you to customize the messages and the methods generated by the command generate_proto by simply reconstruct the file from the data of the dict. To see the data format read the next two sections. Customize gRPC Messages Format grpc_messages attribute is a dict with the format: {[MessageName<String>]: FieldNames<Array<String>>} where: MessageName is the name of the message as it appear in the proto file (SomethingListRequest, SomethingListResponse...) FieldNames is an array of models field. We use django instrospection to find the correct type to display in the proto file Example if we want a message named SomethingSmall: class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingSmall\": [\"uuid\", \"start_date\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; } Specific FieldName Values There is two helper to help building message: - __all__ : Allow you to use all the fields of the model class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": \"__all__\"} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; string rate = 3; } __custom__[proto_type]__[field_name]__ : Allow to specify a name not existing in the model and specify its type. You can put everything you want it will be directly transformed into protobuf format without django instropection. Be carefull when you use it to match your serializer and if you use nested messages that the other message it already declared. class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": [\"uuid\", \"__custom__int32__counter__\", \"__custom__repeated string__last_rates__\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; int32 counter = 2; repeated string last_rates = 3; } Customize gRPC Methods Format grpc_methods attribute is a dict with the format {[MethodName<String>]: { request: Request<Object>, response: Response<Object>}} where Request and Response are object like: {message: MessageName<String>, is_stream: <Boolean>} This data are simply used to generate the line of the method specified by MethodName in the grpc controller. Example: class Something(models.Model): ... class Meta: grpc_methods = { \"StreamList\": { \"request\": {\"is_stream\": False, \"message\": \"SomethingListRequest\"}, \"response\": {\"is_stream\": True, \"message\": \"SomethingListStreamResponse\"}, }, } This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; service ForeignModelController { rpc StreamList(SomethingListRequest) returns (stream SomethingListStreamResponse) {} } This will crash you have not SomethingListRequest and SomethingListStreamResponse defined in the messages of the proto file. See the default generated message and methods Using default methods to simplify overwriting As seen in the first part of this page we have some default generation. But at soon as you overwrite grpc_methods or grpc_messages you loose all the default generation. Often you only want to add a custom field or doesn't want to rewrite the all things. For that you can use the mixins methods get_default_message and get_default_method like: class Something(models.Model): ... class Meta: grpc_messages = { **CreateModelMixin.get_default_message(\"Something\"), **ListModelMixin.get_default_message(\"Something\"), \"SomethingRetrieveRequestCustom\": [\"name\"], \"SomethingRetrieveResponseCustom\": [\"uuid\"], } grpc_methods = { **ListModelMixin.get_default_method(\"Something\"), \"Retrieve\": { \"request\": { \"is_stream\": False, \"message\": \"SomethingRetrieveRequestCustom\", }, \"response\": { \"is_stream\": False, \"message\": \"SomethingRetrieveResponseCustom\", }, }, } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequestCustom { string name = 1; } message SomethingRetrieveResponseCustom { string uuid = 1; } get_default_message and get_default_method exist for all the mixins: CreateModelMixin, ListModelMixin, StreamModelMixin, RetrieveModelMixin, UpdateModelMixin, PartialUpdateModelMixin, DestroyModelMixin. Same for the async model that just inherit from the sync models. You can also use mixins.get_default_grpc_methods and mixins.get_default_grpc_messages to simulate all the defautl configuration and overwrite it after: class Something(models.Model): ... class Meta: grpc_messages = { **get_default_grpc_messages(\"Something\"), \"Something\": [\"uuid\", \"start_date\", \"rate\", \"__custom__string__new_field__\"] } grpc_methods = { **get_default_grpc_methods(\"Something\"), } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; string new_filed = 4; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; }","title":"Generate Proto"},{"location":"generate_proto/#proto-generation","text":"","title":"Proto Generation"},{"location":"generate_proto/#command","text":"To automatically generate proto and python files use the generateproto command: python manage.py generateproto Options Available: Option Shortcut Default value Description --app -a required / use model option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --model -m required / use app option value Name of the django app we want to generate a proto for if not specified will use the model option. If None are specified the command will raise an error. --file -f appName.grpc.appName.proto Path to the generated proto file. --project -p Directory name Name used to build the package name inside the proto file. --dry-run -dr False Print in terminal the protofile content without writing it to a file or generate new python code. --generate-python -gp True Generate python file same time you generate proto file. --check -c False Check if the current protofile is the same that one that will be generated by a new command to be sur your api is sync with your models.","title":"Command"},{"location":"generate_proto/#default-generation","text":"By default each model generate the default viewset as proto file. It allow by default to match all the endpoint given by the generics.AsyncModelService or generics.ModelService classes. For example if we have a model like: class Something(models.Model): uuid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False) start_date = models.DateField() rate = models.CharField(max_length=255, null=True, blank=True, verbose_name=_(\"Rate\")) this will generate a proto like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; }","title":"Default generation"},{"location":"generate_proto/#customize-proto-generation","text":"See exemple used for test here It is possible to adapt the proto generation depending of your need. To customize your proto generation you need to override grpc_messages and grpc_methods attributes of the Meta class of the model: class Something(models.Model): ... class Meta: grpc_messages = {...} grpc_methods = {...} This two dictionnary will allow you to customize the messages and the methods generated by the command generate_proto by simply reconstruct the file from the data of the dict. To see the data format read the next two sections.","title":"Customize proto generation"},{"location":"generate_proto/#customize-grpc-messages","text":"","title":"Customize gRPC Messages"},{"location":"generate_proto/#format","text":"grpc_messages attribute is a dict with the format: {[MessageName<String>]: FieldNames<Array<String>>} where: MessageName is the name of the message as it appear in the proto file (SomethingListRequest, SomethingListResponse...) FieldNames is an array of models field. We use django instrospection to find the correct type to display in the proto file Example if we want a message named SomethingSmall: class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingSmall\": [\"uuid\", \"start_date\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; }","title":"Format"},{"location":"generate_proto/#specific-fieldname-values","text":"There is two helper to help building message: - __all__ : Allow you to use all the fields of the model class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": \"__all__\"} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; string start_date = 2; string rate = 3; } __custom__[proto_type]__[field_name]__ : Allow to specify a name not existing in the model and specify its type. You can put everything you want it will be directly transformed into protobuf format without django instropection. Be carefull when you use it to match your serializer and if you use nested messages that the other message it already declared. class Something(models.Model): ... class Meta: grpc_messages = {\"SomethingAll\": [\"uuid\", \"__custom__int32__counter__\", \"__custom__repeated string__last_rates__\"]} grpc_methods = {} This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; message SomethingSmall { string uuid = 1; int32 counter = 2; repeated string last_rates = 3; }","title":"Specific FieldName Values"},{"location":"generate_proto/#customize-grpc-methods","text":"","title":"Customize gRPC Methods"},{"location":"generate_proto/#format_1","text":"grpc_methods attribute is a dict with the format {[MethodName<String>]: { request: Request<Object>, response: Response<Object>}} where Request and Response are object like: {message: MessageName<String>, is_stream: <Boolean>} This data are simply used to generate the line of the method specified by MethodName in the grpc controller. Example: class Something(models.Model): ... class Meta: grpc_methods = { \"StreamList\": { \"request\": {\"is_stream\": False, \"message\": \"SomethingListRequest\"}, \"response\": {\"is_stream\": True, \"message\": \"SomethingListStreamResponse\"}, }, } This will generate a proto file like: syntax = \"proto3\"; package tutorial.quickstart; service ForeignModelController { rpc StreamList(SomethingListRequest) returns (stream SomethingListStreamResponse) {} } This will crash you have not SomethingListRequest and SomethingListStreamResponse defined in the messages of the proto file. See the default generated message and methods","title":"Format"},{"location":"generate_proto/#using-default-methods-to-simplify-overwriting","text":"As seen in the first part of this page we have some default generation. But at soon as you overwrite grpc_methods or grpc_messages you loose all the default generation. Often you only want to add a custom field or doesn't want to rewrite the all things. For that you can use the mixins methods get_default_message and get_default_method like: class Something(models.Model): ... class Meta: grpc_messages = { **CreateModelMixin.get_default_message(\"Something\"), **ListModelMixin.get_default_message(\"Something\"), \"SomethingRetrieveRequestCustom\": [\"name\"], \"SomethingRetrieveResponseCustom\": [\"uuid\"], } grpc_methods = { **ListModelMixin.get_default_method(\"Something\"), \"Retrieve\": { \"request\": { \"is_stream\": False, \"message\": \"SomethingRetrieveRequestCustom\", }, \"response\": { \"is_stream\": False, \"message\": \"SomethingRetrieveResponseCustom\", }, }, } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequestCustom { string name = 1; } message SomethingRetrieveResponseCustom { string uuid = 1; } get_default_message and get_default_method exist for all the mixins: CreateModelMixin, ListModelMixin, StreamModelMixin, RetrieveModelMixin, UpdateModelMixin, PartialUpdateModelMixin, DestroyModelMixin. Same for the async model that just inherit from the sync models. You can also use mixins.get_default_grpc_methods and mixins.get_default_grpc_messages to simulate all the defautl configuration and overwrite it after: class Something(models.Model): ... class Meta: grpc_messages = { **get_default_grpc_messages(\"Something\"), \"Something\": [\"uuid\", \"start_date\", \"rate\", \"__custom__string__new_field__\"] } grpc_methods = { **get_default_grpc_methods(\"Something\"), } this will generate something like: syntax = \"proto3\"; package tutorial.quickstart; import \"google/protobuf/empty.proto\"; service SomethingController { rpc List(SomethingListRequest) returns (SomethingListResponse) {} rpc Create(Something) returns (Something) {} rpc Retrieve(SomethingRetrieveRequest) returns (Something) {} rpc Update(Something) returns (Something) {} rpc Destroy(SomethingDestroyRequest) returns (google.protobuf.Empty) {} } message Something { string uuid = 1; string start_date = 2; string rate = 3; string new_filed = 4; } message SomethingListRequest { } message SomethingListResponse { repeated Something results = 1; } message SomethingRetrieveRequest { string uuid = 1; } message SomethingDestroyRequest { string uuid = 1; }","title":"Using default methods to simplify overwriting"},{"location":"generic_service/","text":"","title":"Generic Service"},{"location":"logging/","text":"","title":"Logging"},{"location":"model_service/","text":"","title":"Model Service"},{"location":"proto_serializer/","text":"","title":"Proto Serializer"},{"location":"server_and_service_register/","text":"","title":"Server and service register"},{"location":"settings/","text":"","title":"Settings"},{"location":"sync_vs_async/","text":"","title":"Sync vs Async"},{"location":"testing/","text":"","title":"Testing"}]}